import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

export function createScene(canvas) {
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 15);

  const renderer = new THREE.WebGLRenderer({ canvas: canvas });
  renderer.setSize(window.innerWidth, window.innerHeight);

  const axesHelper = new THREE.AxesHelper(5);
  scene.add(axesHelper);

  const light = new THREE.PointLight(0xffffff, 1, 0);
  light.position.set(50, 50, 50);
  scene.add(light);

  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);

  const loader = new THREE.FontLoader();

  const tactics = [
    "Initial Access",
    "Execution",
    "Persistence",
    "Privilege Escalation",
    "Defense Evasion",
    "Credential Access",
    "Discovery",
    "Lateral Movement",
    "Collection",
    "Exfiltration",
    "Command and Control",
    "Impact"
  ];

function getPositionOnSineWave(index, total, amplitude, wavelength, xOffset) {
  const x = xOffset + (wavelength * index) / total;
  const y = amplitude * Math.sin(2 * Math.PI * (x / wavelength));
  return new THREE.Vector3(x, y, 0);
}


loader.load('fonts/Your_Font.json', function (font) {
  tactics.forEach((tactic, index) => {
    // Create a text geometry for each tactic with the desired parameters
    const geometry = new THREE.TextGeometry(tactic, {
      // Parameters for the text geometry
    });

    // Create a material for the text geometry
    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00 });

    // Create a mesh for the text geometry and material
    const mesh = new THREE.Mesh(geometry, material);

    // Calculate the position for each text geometry along the sine wave path
    const position = getPositionOnSineWave(
      index,
      tactics.length,
      3, // amplitude
      10, // wavelength
      1 // xOffset
    );
    mesh.position.copy(position);

    // Add the mesh to the scene
    scene.add(mesh);
  });
});

  const controls = new OrbitControls(camera, renderer.domElement);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }

  animate();
}
